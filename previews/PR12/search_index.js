var documenterSearchIndex = {"docs":
[{"location":"bezier_extraction/#Bezier-extraction","page":"Bezier extraction","title":"Bezier extraction","text":"","category":"section"},{"location":"bezier_extraction/","page":"Bezier extraction","title":"Bezier extraction","text":"The basefunctions used in IGA (B-splines, NURBS, ...) exist over multiple adjecent elements. This is in contrast to traditional finite element method, where identical shape function are defined withing all elements. This makes it difficult to incorprate IGA in to a standard finite element code. The bezier extraction technique, introduced by Borden et.al, solves this problem by allowing numerical integration of smooth function to be performed on C0 Bezier elements.","category":"page"},{"location":"bezier_extraction/","page":"Bezier extraction","title":"Bezier extraction","text":"The C^p-continiuos B-Spline basis functions on an element, boldsymbol N^e can be computeded from the C^0 bernstein polynominals, boldsymbol B^e, as","category":"page"},{"location":"bezier_extraction/","page":"Bezier extraction","title":"Bezier extraction","text":"    boldsymbol N^e = boldsymbol C^e boldsymbol B^e","category":"page"},{"location":"bezier_extraction/","page":"Bezier extraction","title":"Bezier extraction","text":"where boldsymbol C^e is the bezier extraction operator for the current cell. This operator can be pre-computed for each element in the IGA-mesh. With the help of this relation, it can be shown that the NURBS can be computed as ","category":"page"},{"location":"bezier_extraction/","page":"Bezier extraction","title":"Bezier extraction","text":"    boldsymbol R^e = boldsymbol W^e frac boldsymbol N^eW(xi) = boldsymbol W^e boldsymbol C^e fracboldsymbol B^eW^b(xi)","category":"page"},{"location":"bezier_extraction/","page":"Bezier extraction","title":"Bezier extraction","text":"where boldsymbol W^e is a diagonal matrix of the rational weights, w_I I = 12N, and W(xi) and W^b(xi) are the weight functions ","category":"page"},{"location":"bezier_extraction/","page":"Bezier extraction","title":"Bezier extraction","text":"    W(xi) = W^b(xi) = sum_I^N = N(xi)  w_I = sum_I^N = B(xi)  w^b_I  ","category":"page"},{"location":"bezier_extraction/","page":"Bezier extraction","title":"Bezier extraction","text":"It can also be show that a NURBS-surface (or curve/solid) can be represented using the Bernstein basis functions,","category":"page"},{"location":"bezier_extraction/","page":"Bezier extraction","title":"Bezier extraction","text":"    S(xi eta) = boldsymbol X^e boldsymbol R(xi eta) = boldsymbol X_b^e boldsymbol B(xi eta)","category":"page"},{"location":"bezier_extraction/","page":"Bezier extraction","title":"Bezier extraction","text":"where boldsymbol X^e are the control points for the NURBS surface, and boldsymbol X_b^e are controlpoints on the bezier element, caluculated as ","category":"page"},{"location":"bezier_extraction/","page":"Bezier extraction","title":"Bezier extraction","text":"    boldsymbol X_b^e = frac1W(xi) left(boldsymbol C^eright)^T boldsymbol W^e boldsymbol X^e","category":"page"},{"location":"bezier_extraction/","page":"Bezier extraction","title":"Bezier extraction","text":"The equations above show that we can pre-compute the bernstein basis values at some gauss points (similar to how we pre compute the shape values for Lagrange basis functions), and then using the bezier extraction operator, calculate the NURBS values. In the code, the reinitilzation of the shape functions is performed like this.","category":"page"},{"location":"bezier_extraction/","page":"Bezier extraction","title":"Bezier extraction","text":"ip = Bernstein{2,orders}()\nqr_cell = QuadratureRule{2,RefCube}(4)\n\ncv = BezierCellValues( CellVectorValues(qr_cell, ip) )\n\n...\n\nextr = get_extraction_operator(grid, cellid) # Extraction operator\nX = getcoordinates(grid, cellid) #Nurbs coords\nw = getweights(grid, cellid)       #Nurbs weights\nwᴮ = compute_bezier_points(extr, w)\nXᴮ = inv.(wᴮ) .* compute_bezier_points(extr, w.*X)\n\nreinit!(cv, (Xᴮ, wᴮ))","category":"page"},{"location":"bezier_values/#BezierValues.jl","page":"BezierValues.jl","title":"BezierValues.jl","text":"","category":"section"},{"location":"bezier_values/","page":"BezierValues.jl","title":"BezierValues.jl","text":"Documentation for IGA.jl","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"EditURL = \"https://github.com/lijas/IGA.jl/blob/master/docs/src/literate/plate_with_hole.jl\"","category":"page"},{"location":"examples/plate_with_hole/#Infinite-plate-with-hole","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"","category":"section"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"(Image: )","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"In this example we will solve a simple elasticity problem; an infinite plate with a hole. The main goal of the tutorial is to show how one can solve the problem using Isogeometric Analysis (IGA), or in other words, solving a FE-problem with splines as the basis/shape functions. By using so called bezier extraction, we will see that most of the structure of the code will be the same as in standard FE-codes (however many differences are happening \"under the hood\").","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"note: Note\nIt is expected that the reader already be familiar with IGA and the concept of \"bezier extraction\". It is also expected that the reader is familiar with the Ferrite package. In particular Ferrite.DofHandler and Ferrite.CellValues.","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Start by loading the necessary packages","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"using Ferrite, IGA, LinearAlgebra","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Next we define the functions for the integration of the element stiffness matrix and traction force. These functions will be the same as for a normal finite elment problem, but with the difference that we need the cell coorinates AND cell weights (the weights from the NURBS shape functions), to reinitilize the shape values, dNdx. Read this page, to see how the shape values are reinitilized.","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"function integrate_element!(ke::AbstractMatrix, C::SymmetricTensor{4,2}, cv)\n    n_basefuncs = getnbasefunctions(cv)\n\n    δɛ = [zero(SymmetricTensor{2,2,Float64}) for i in 1:n_basefuncs]\n    for q_point in 1:getnquadpoints(cv)\n\n        for i in 1:n_basefuncs\n            δɛ[i] = symmetric(shape_gradient(cv, q_point, i))\n        end\n\n        dΩ = getdetJdV(cv, q_point)\n        for i in 1:n_basefuncs\n            for j in 1:n_basefuncs\n                ke[i, j] += (δɛ[i] ⊡ C ⊡ δɛ[j]) * dΩ\n            end\n        end\n    end\nend;\n\nfunction integrate_traction_force!(fe::AbstractVector, t::Vec{2}, fv)\n    n_basefuncs = getnbasefunctions(fv)\n\n    for q_point in 1:getnquadpoints(fv)\n        dA = getdetJdV(fv, q_point)\n        for i in 1:n_basefuncs\n            δu = shape_value(fv, q_point, i)\n            fe[i] += t ⋅ δu * dA\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"The assembly loop is also written in almost the same way as in a standard finite element code. The key differences will be described in the next paragraph,","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"function assemble_problem(dh::DofHandler, grid, cv, fv, stiffmat, traction)\n\n    f = zeros(ndofs(dh))\n    K = allocate_matrix(dh)\n    assembler = start_assemble(K, f)\n\n    n = getnbasefunctions(cv)\n    celldofs = zeros(Int, n)\n    fe = zeros(n)     # element force vector\n    ke = zeros(n, n)  # element stiffness matrix\n\n    n = Ferrite.nnodes_per_cell(grid)\n\tw = zeros(Float64, n)\n\tx = zeros(Vec{2}, n)\n\twb = zeros(Float64, n)\n\txb = zeros(Vec{2}, n)\n\n    # Assemble internal forces\n    for cellid in 1:getncells(grid)\n        fill!(fe, 0.0)\n        fill!(ke, 0.0)\n        celldofs!(celldofs, dh, cellid)\n\n        # In a normal finite elment code, this is the point where we usually get the coordinates of the element `X = getcoordinates(grid, cellid)`. In this case, however,\n        # we also require the cell weights, and we need to transform them to the bezier mesh.\n        extr = get_extraction_operator(grid, cellid) # Extraction operator\n        get_bezier_coordinates!(xb,wb,x,w,grid,cellid) #Nurbs coords\n        set_bezier_operator!(cv, extr, w)\n        reinit!(cv, (xb,wb)) ## Reinit cellvalues by passsing both bezier coords and weights\n        integrate_element!(ke, stiffmat, cv)\n\n        assemble!(assembler, celldofs, ke, fe)\n    end\n\n    # Assamble external forces\n    for (cellid, faceid) in getfacetset(grid, \"left\")\n        fill!(fe, 0.0)\n\n        celldofs!(celldofs, dh, cellid)\n\n        beziercoords = getcoordinates(grid, cellid)\n        reinit!(fv, beziercoords, faceid)\n\n        integrate_traction_force!(fe, traction, fv)\n        f[celldofs] += fe\n    end\n\n\n    return K, f\nend;\nnothing #hide","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"This is a function that returns the elastic stiffness matrix","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"function get_material(; E, ν)\n    λ = E*ν / ((1 + ν) * (1 - 2ν))\n    μ = E / (2(1 + ν))\n    δ(i,j) = i == j ? 1.0 : 0.0\n    g(i,j,k,l) = λ*δ(i,j)*δ(k,l) + μ*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k))\n\n    return SymmetricTensor{4, 2}(g)\nend;\nnothing #hide","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"We also create a function that calculates the stress in each quadrature point, given the cell displacement and such...","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"function calculate_stress(dh, cv::BezierCellValues, C::SymmetricTensor{4,2}, u::Vector{Float64})\n\n    celldofs = zeros(Int, ndofs_per_cell(dh))\n\n    #Store the stresses in each qp for all cells\n    cellstresses = Vector{SymmetricTensor{2,2,Float64,3}}[]\n\n    for cellid in 1:getncells(dh.grid)\n\n        bc = getcoordinates(dh.grid, cellid)\n\n        reinit!(cv, bc)\n        celldofs!(celldofs, dh, cellid)\n\n        ue = u[celldofs]\n        qp_stresses = SymmetricTensor{2,2,Float64,3}[]\n        for qp in 1:getnquadpoints(cv)\n            ε = symmetric(function_gradient(cv, qp, ue))\n            σ = C ⊡ ε\n            push!(qp_stresses, σ)\n        end\n        push!(cellstresses, qp_stresses)\n    end\n\n    return cellstresses\nend;\nnothing #hide","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Now we have all the parts needed to solve the problem. We begin by generating the mesh. IGA.jl includes a couple of different functions that can generate different nurbs patches. In this example, we will generate the patch called \"plate with hole\". Note, currently this function can only generate the patch with second order basefunctions.","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"function solve()\n    order = 2 # order of the NURBS\n    nels = (20,10) # Number of elements\n    nurbsmesh = generate_nurbs_patch(:plate_with_hole, nels, order)","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Performing the computation on a NURBS-patch is possible, but it is much easier to using \"bezier-extraction\". For this we transform the NURBS-patch into a BezierGrid. The BezierGrid is identical to the standard Ferrite.Grid, but includes the NURBS-weights and bezier extraction operators.","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    grid = BezierGrid(nurbsmesh)","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Next, create some facesets. This is done in the same way as in normal Ferrite-code. One thing to note however, is that the nodes/controlpoints, does not necessary lay exactly on the geometry due to the non-interlapotry nature of NURBS spline functions. However, in most cases they will be close enough to use the Ferrite functions below.","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    addnodeset!(grid, \"right\", (x) -> x[1] ≈ -0.0)\n    addfacetset!(grid, \"left\", (x) -> x[1] ≈ -4.0)\n    addfacetset!(grid, \"bot\", (x) -> x[2] ≈ 0.0)\n    addfacetset!(grid, \"right\", (x) -> x[1] ≈ 0.0)","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Create the cellvalues storing the shape function values. Note that the CellVectorValues/FaceVectorValues are wrapped in a BezierValues. It is in the reinit-function of the BezierValues that the actual bezier transformation of the shape values is performed.","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    ip_geo = IGAInterpolation{RefQuadrilateral,order}()\n    ip_u = ip_geo^2\n    qr_cell = QuadratureRule{RefQuadrilateral}(4)\n    qr_face = FacetQuadratureRule{RefQuadrilateral}(3)\n\n    cv = BezierCellValues(qr_cell, ip_u)\n    fv = BezierFacetValues(qr_face, ip_u)","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Distribute dofs as normal","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    dh = DofHandler(grid)\n    add!(dh, :u, ip_u)\n    close!(dh)\n\n    ae = zeros(ndofs(dh))\n    IGA.apply_analytical_iga!(ae, dh, :u, x->x)","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Add two symmetry boundary condintions. Bottom face should only be able to move in x-direction, and the right boundary should only be able to move in y-direction","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    ch = ConstraintHandler(dh)\n    dbc1 = Dirichlet(:u, getfacetset(grid, \"bot\"), (x, t) -> 0.0, 2)\n    dbc2 = Dirichlet(:u, getfacetset(grid, \"right\"), (x, t) -> 0.0, 1)\n    add!(ch, dbc1)\n    add!(ch, dbc2)\n    close!(ch)\n    update!(ch, 0.0)","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Define stiffness matrix and traction force","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    stiffmat = get_material(E = 100, ν = 0.3)\n    traction = Vec((-10.0, 0.0))\n    K,f = assemble_problem(dh, grid, cv, fv, stiffmat, traction)","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Solve","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    apply!(K, f, ch)\n    u = K\\f","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Now we want to export the results to VTK. So we calculate the stresses in each gauss-point, and project them to the nodes using the L2Projector from Ferrite. Node that we need to create new CellValues of type CellScalarValues, since the L2Projector only works with scalar fields.","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    cellstresses = calculate_stress(dh, cv, stiffmat, u)","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"L2 projections currently broken for IGA projector = L2Projector(ipu, grid) σnodes = project(projector, cellstresses, qr_cell)","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    IGA.VTKIGAFile(\"plate_with_hole.vtu\", grid) do vtk\n        write_solution(vtk, dh, u)\n        #IGA.write_projections(vtk, projector, σ_nodes, \"σ\")\n    end\n\nend;\nnothing #hide","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Call the function","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"solve()","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"","category":"page"},{"location":"examples/plate_with_hole/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"EditURL = \"https://github.com/lijas/IGA.jl/blob/master/docs/src/literate/structuralvibrations.jl\"","category":"page"},{"location":"examples/structuralvibrations/#Structural-vibrations","page":"Structural vibrations","title":"Structural vibrations","text":"","category":"section"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"In this example, we will compare traditional Finite Element Method (FEM) with Isogeometric Analysis (IGA) for analysing structural vibration problems. We aim to replicate the results from Cottrell, J. et al, Isogeometric analysis of structural vibrations, In Computer Methods in Applied Mechanics and Engineering https://doi.org/10.1016/j.cma.2005.09.027","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"Consider the structural vibrations of an elastic rod of unit length, whose natural frequencies and modes are goverened by:","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"u_xx + omega_n^2 u = 0 quad x in (01)","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"subjected to boundary conditions:","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"u(0) = u(1) = 0","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"where u is the displacement field, and omega_n is n:th natural frequency.","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"After discretisation, we formulate the generalised eigenvalue problem, which allows us to solve for the natural frequencies and modes boldsymbolphi_n:","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"(boldsymbolK - omega^2_n boldsymbolM) boldsymbolphi_n = 0","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"Here, boldsymbolK and boldsymbolM are the standard stiffness and mass matrices.","category":"page"},{"location":"examples/structuralvibrations/#Main-code","page":"Structural vibrations","title":"Main code","text":"","category":"section"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"Per usual, we first load the relevant packages","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"using Ferrite, IGA, LinearAlgebra, Plots","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"Next we define the element routine used to compute the element stiffness and mass matrices","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"function stiffness_and_mass_matrix!(ke, me, cv)\n    for qp in 1:getnquadpoints(cv)\n        dV = getdetJdV(cv,qp)\n        for i in 1:getnbasefunctions(cv)\n            for j in 1:getnbasefunctions(cv)\n                ke[i,j] += shape_gradient(cv, qp, i) ⋅ shape_gradient(cv, qp, j) * dV\n                me[i,j] += shape_value(cv, qp, i) * shape_value(cv, qp, j) * dV\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"We also create a function for computing the natural frequencies omega_n. The input for the function is the grid (either a FEM or IGA mesh), and the corresponing cellvalues and interpolations (either Lagrange or IGAInterpolaiton).","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"function compute_eigenvalues(grid, cellvalues, ip)\n\n    #Create dofhandler\n    dh = DofHandler(grid)\n    add!(dh, :u, ip)\n    close!(dh)\n\n    #initlize matrices\n    nbf = getnbasefunctions(ip)\n    ke = zeros(nbf,nbf)\n    me = zeros(nbf,nbf)\n    K = allocate_matrix(dh)\n    M = allocate_matrix(dh)\n\n    #assemble system\n    assembler_K = start_assemble(K)\n    assembler_M = start_assemble(M)\n    for cellid in 1:getncells(grid)\n        fill!(ke, 0.0)\n        fill!(me, 0.0)\n        coords = getcoordinates(grid, cellid)\n        dofs = celldofs(dh, cellid)\n\n        reinit!(cellvalues, coords)\n        stiffness_and_mass_matrix!(ke, me, cellvalues)\n\n        assemble!(assembler_K, dofs, ke)\n        assemble!(assembler_M, dofs, me)\n    end\n\n    #apply BC\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfacetset(grid, \"left\"), x->(0.0,)))\n    add!(ch, Dirichlet(:u, getfacetset(grid, \"right\"), x->(0.0,)))\n    close!(ch)\n    apply!(K, ch)\n\n    #Solve generlized eigenvalue problem\n    λ, ϕ = eigen(Matrix(K), Matrix(M)) #Note, we need to convert to full matrices\n    ω = sqrt.(λ)\n    return ω\nend;\nnothing #hide","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"We can now solve for the natural frequencies for both the FEM and IGA case. We will use quadratic shape functions and a total of 999 DOFs.","category":"page"},{"location":"examples/structuralvibrations/#Finite-element-solution","page":"Structural vibrations","title":"Finite element solution","text":"","category":"section"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"const N = 999    # Number of desired dofs\nconst order = 2  # Order of polynomial\nconst L = 1.0    # Length of beam\nconst nel_fem = (N-1) ÷ order; # Number of elements\ngrid = generate_grid(Line, (nel_fem,), Vec(0.0), Vec(L))\n\nip = Lagrange{RefLine,order}()\nqr = QuadratureRule{RefLine}(6)\ncellvalues = CellValues(qr, ip)\n\nω_fem = compute_eigenvalues(grid, cellvalues, ip);\nnothing #hide","category":"page"},{"location":"examples/structuralvibrations/#Isogeometric-solution","page":"Structural vibrations","title":"Isogeometric solution","text":"","category":"section"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"const nel_iga = N-order # Number of elements\ngrid = generate_grid(BezierCell{RefLine,order}, (nel_iga,), Vec(0.0), Vec(L))\n\nip = IGAInterpolation{RefLine,order}()\nqr = QuadratureRule{RefLine}(6)\ncellvalues = BezierCellValues(qr, ip)\n\nω_iga = compute_eigenvalues(grid, cellvalues, ip);\nnothing #hide","category":"page"},{"location":"examples/structuralvibrations/#Results","page":"Structural vibrations","title":"Results","text":"","category":"section"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"Now, we can plot and compare the normalised solutions. From the results, we observe that the accuracy of the FEM solution diminishes significantly for nN05. This highlights the advantageous properties of IGA for structural dynamics problems.","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"analytical_ω_f(n) = π*n\nω_analytical = analytical_ω_f.(1:N)\n\nnormalised_ω_fem  = ω_fem ./ ω_analytical\nnormalised_ω_iga  = ω_iga ./ ω_analytical\n\nn_range = range(0,1,N)\nfig = plot(; title=\"Eigenvalues\", ylabel = \"Normalised eigenvalue\", xlabel=\"Normalised eigen number\")\nplot!(fig, n_range, normalised_ω_fem, label=\"Quadratic FEM\")\nplot!(fig, n_range, normalised_ω_iga, label=\"Quadratic IGA\")","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"","category":"page"},{"location":"examples/structuralvibrations/","page":"Structural vibrations","title":"Structural vibrations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"bsplines_nurbs/#Splines","page":"Splines","title":"Splines","text":"","category":"section"},{"location":"bsplines_nurbs/#B-Splines","page":"Splines","title":"B-Splines","text":"","category":"section"},{"location":"bsplines_nurbs/","page":"Splines","title":"Splines","text":"The univariate B-Spline basis are defined by a knot vector, which is a non-decreasing parametric coordinate written ad Xi = xi_1  xi_n+p+1, where p is the polynominal degree of the  basis function, and n is the number of basis functions. The B-splines are defined recursivily as ","category":"page"},{"location":"bsplines_nurbs/","page":"Splines","title":"Splines","text":"    hat N_Ap(xi) = fracxi - xi_Axi_A+p - xi_A hat N_Ap-1(xi) + fracxi_A+p+1 - xixi_A+p+1 - xi_A+1 hat N_A+1p-1(xi)","category":"page"},{"location":"bsplines_nurbs/","page":"Splines","title":"Splines","text":"and ","category":"page"},{"location":"bsplines_nurbs/","page":"Splines","title":"Splines","text":"    hat N_A0(xi) = \n    begincases\n    1  xi_a leq xi  xi_A+1\n    0  textotherwise\n    endcases","category":"page"},{"location":"bsplines_nurbs/","page":"Splines","title":"Splines","text":"The B-Spline basis functions can be used the define geometries (curve/surface/solid). Below, an example of a B-Splines surface is presented,","category":"page"},{"location":"bsplines_nurbs/","page":"Splines","title":"Splines","text":"    boldsymbol S(xieta) = sum_A=1^N boldsymbol X_A N_A(xi eta)","category":"page"},{"location":"bsplines_nurbs/","page":"Splines","title":"Splines","text":"where boldsymbol X_A are the control points (coordinates), and N_A are a combination of two univariate B-spline functions in different parametric directions,","category":"page"},{"location":"bsplines_nurbs/","page":"Splines","title":"Splines","text":"    N_Axi eta = hat N_i^xi(xi) cdot hat N_j^eta(eta)","category":"page"},{"location":"bsplines_nurbs/","page":"Splines","title":"Splines","text":"Here, hat N_i^xi and hat N_j^eta have their own set of knot vectors.","category":"page"},{"location":"bsplines_nurbs/#NURBS","page":"Splines","title":"NURBS","text":"","category":"section"},{"location":"bsplines_nurbs/","page":"Splines","title":"Splines","text":"TODO","category":"page"},{"location":"#IGA.jl","page":"Home","title":"IGA.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Small toolbox for Isogeometric anlysis. Built on top of Ferrite","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/lijas/IGA.jl.git","category":"page"},{"location":"#About-IGA","page":"Home","title":"About IGA","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From wikipedia: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Isogeometric analysis is a computational approach that offers the possibility of integrating finite element analysis (FEA) into conventional NURBS-based CAD design tools. Currently, it is necessary to convert data between CAD and FEA packages to analyse new designs during development, a difficult task since the two computational geometric approaches are different. Isogeometric analysis employs complex NURBS geometry (the basis of most CAD packages) in the FEA application directly. This allows models to be designed, tested and adjusted in one go, using a common data set.","category":"page"}]
}
