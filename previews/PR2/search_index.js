var documenterSearchIndex = {"docs":
[{"location":"bezier_values/#BezierValues.jl","page":"BezierValues.jl","title":"BezierValues.jl","text":"","category":"section"},{"location":"bezier_values/","page":"BezierValues.jl","title":"BezierValues.jl","text":"Documentation for IGA.jl","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"EditURL = \"https://github.com/lijas/IGA.jl/blob/master/docs/src/literate/example1.jl\"","category":"page"},{"location":"examples/example1/#Infinite-plate-with-hole","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"","category":"section"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"(Image: )","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"In this example we will solve a simple elasticity problem; an infinite plate with a hole. The main goal of the tutorial is to show how one can solve the problem using Isogeometric Analysis (IGA), or in other words, solving a FE-problem with splines as the basis/shape functions. By using so called bezier extraction, we will see that most of the structure of the code will be the same as in standard FE-codes (however many differences are happening \"under the hood\").","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"note: Note\nIt is expected that the reader already be familiar with IGA and the concept of \"bezier extraction\". It is also expected that the reader is familiar with the JuAFEM package. In particular JuAFEM.DofHandler and JuAFEM.CellValues.","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Start by loading the necessary packages","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"using JuAFEM, IGA, LinearAlgebra","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Next we define the functions for the integration of the element stiffness matrix and traction force. These functions will be the same as for a normal finite elment problem, but with the difference that we need the cell coorinates AND cell weights (the weights from the NURBS shape functions), to reinitilize the shape values, dNdx. Read this page, to see how the shape values are reinitilized.","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"function integrate_element!(ke::AbstractMatrix, Xᴮ::Vector{Vec{2,Float64}}, wᴮ::Vector{Float64}, C::SymmetricTensor{4,2}, cv)\n    n_basefuncs = getnbasefunctions(cv)\n\n    reinit!(cv, (Xᴮ, wᴮ)) ## Reinit cellvalues by passsing both bezier coords and weights\n\n    δɛ = [zero(SymmetricTensor{2,2,Float64}) for i in 1:n_basefuncs]\n    for q_point in 1:getnquadpoints(cv)\n\n        for i in 1:n_basefuncs\n            δɛ[i] = symmetric(shape_gradient(cv, q_point, i))\n        end\n\n        dΩ = getdetJdV(cv, q_point)\n        for i in 1:n_basefuncs\n            for j in 1:n_basefuncs\n                ke[i, j] += (δɛ[i] ⊡ C ⊡ δɛ[j]) * dΩ\n            end\n        end\n    end\nend;\n\nfunction integrate_traction_force!(fe::AbstractVector, Xᴮ::Vector{Vec{2,Float64}}, wᴮ::Vector{Float64}, t::Vec{2}, fv, faceid::Int)\n    n_basefuncs = getnbasefunctions(fv)\n\n    reinit!(fv, (Xᴮ, wᴮ), faceid) ## Reinit cellvalues by passsing both bezier coords and weights\n\n    for q_point in 1:getnquadpoints(fv)\n        dA = getdetJdV(fv, q_point)\n        for i in 1:n_basefuncs\n            δu = shape_value(fv, q_point, i)\n            fe[i] += t ⋅ δu * dA\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"The assembly loop is also written in almost the same way as in a standard finite element code. The key differences will be described in the next paragraph,","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"function assemble_problem(dh::MixedDofHandler, grid, cv, fv, stiffmat, traction)\n\n    f = zeros(ndofs(dh))\n    K = create_sparsity_pattern(dh)\n    assembler = start_assemble(K, f)\n\n    n = getnbasefunctions(cv)\n    celldofs = zeros(Int, n)\n    fe = zeros(n)     # element force vector\n    ke = zeros(n, n)  # element stiffness matrix\n\n    # Assemble internal forces\n    for cellid in 1:getncells(grid)\n        fill!(fe, 0.0)\n        fill!(ke, 0.0)\n        celldofs!(celldofs, dh, cellid)","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"In a normal finite elment code, this is the point where we usually get the coordinates of the element X = getcoordinates(grid, cellid). In this case, however, we also require the cell weights, and we need to transform them to the bezier mesh.","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"        extr = grid.beo[cellid] # Extraction operator\n        X = getcoordinates(grid.grid, cellid) #Nurbs coords\n        w = getweights(grid, cellid)       #Nurbs weights\n        wᴮ = compute_bezier_points(extr, w)\n        Xᴮ = inv.(wᴮ) .* compute_bezier_points(extr, w.*X)","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"tip: Tip\nSince the operations above are quite common in IGA, there is a helper-function called get_bezier_coordinates(grid, cellid), which return the bezier coorinates and weights directly.","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Furthermore, we pass the bezier extraction operator to the CellValues/Beziervalues.","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"        set_bezier_operator!(cv, w.*extr)\n\n        integrate_element!(ke, Xᴮ, wᴮ, stiffmat, cv)\n        assemble!(assembler, celldofs, ke, fe)\n    end\n\n    # Assamble external forces\n    for (cellid, faceid) in getfaceset(grid, \"left\")\n        fill!(fe, 0.0)\n\n        celldofs!(celldofs, dh, cellid)\n\n        extr = grid.beo[cellid]\n        Xᴮ, wᴮ = get_bezier_coordinates(grid, cellid)\n        w = getweights(grid, cellid)\n\n        set_bezier_operator!(fv, w.*extr)\n\n        integrate_traction_force!(fe, Xᴮ, wᴮ, traction, fv, faceid)\n        f[celldofs] += fe\n    end\n\n\n    return K, f\nend;\nnothing #hide","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"This is a function that returns the elastic stiffness matrix","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"function get_material(; E, ν)\n    λ = E*ν / ((1 + ν) * (1 - 2ν))\n    μ = E / (2(1 + ν))\n    δ(i,j) = i == j ? 1.0 : 0.0\n    g(i,j,k,l) = λ*δ(i,j)*δ(k,l) + μ*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k))\n\n    return SymmetricTensor{4, 2}(g)\nend;\nnothing #hide","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"We also create a function that calculates the stress in each quadrature point, given the cell displacement and such...","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"function calculate_stress(dh, cv::JuAFEM.Values, C::SymmetricTensor{4,2}, u::Vector{Float64})\n\n    celldofs = zeros(Int, ndofs_per_cell(dh))\n\n    #Store the stresses in each qp for all cells\n    cellstresses = Vector{SymmetricTensor{2,2,Float64,3}}[]\n\n    for cellid in 1:getncells(dh.grid)\n\n        extr = dh.grid.beo[cellid]\n        Xᴮ, wᴮ = get_bezier_coordinates(dh.grid, cellid)\n        w = getweights(dh.grid, cellid)\n\n        set_bezier_operator!(cv, w.*extr)\n        reinit!(cv, (Xᴮ, wᴮ))\n        celldofs!(celldofs, dh, cellid)\n\n        ue = u[celldofs]\n        qp_stresses = SymmetricTensor{2,2,Float64,3}[]\n        for qp in 1:getnquadpoints(cv)\n            ɛ = symmetric(function_gradient(cv, qp, ue))\n            σ = C ⊡ ε\n            push!(qp_stresses, σ)\n        end\n        push!(cellstresses, qp_stresses)\n    end\n\n    return cellstresses\nend;\nnothing #hide","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Now we have all the parts needed to solve the problem. We begin by generating the mesh. IGA.jl includes a couple of different functions that can generate different nurbs patches. In this example, we will generate the patch called \"plate with hole\". Note, currently this function can only generate the patch with second order basefunctions.","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"function solve()\n    orders = (2,2) # Order in the ξ and η directions .\n    nels = (20,10) # Number of elements\n    nurbsmesh = generate_nurbs_patch(:plate_with_hole, nels)","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Performing the computation on a NURBS-patch is possible, but it is much easier to use the bezier-extraction technique. For this we transform the NURBS-patch into a BezierGrid. The BezierGrid is identical to the standard JuAFEM.Grid, but includes the NURBS-weights and bezier extraction operators.","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    grid = BezierGrid(nurbsmesh)","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Next, create some facesets. This is done in the same way as in normal JuAFEM-code. One thing to note however, is that the nodes/controlpoints, does not necessary lay exactly on the geometry due to the non-interlapotry nature of NURBS spline functions. However, in most cases they will be close enough to use the JuAFEM functions below.","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    addnodeset!(grid,\"right\", (x) -> x[1] ≈ -0.0)\n    addfaceset!(grid, \"left\", (x) -> x[1] ≈ -4.0)\n    addfaceset!(grid, \"bot\", (x) -> x[2] ≈ 0.0)\n    addfaceset!(grid, \"right\", (x) -> x[1] ≈ 0.0)","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Create the cellvalues storing the shape function values. Note that the CellVectorValues/FaceVectorValues are wrapped in a BezierValues. It is in the reinit-function of the BezierValues that the actual bezier transformation of the shape values is performed.","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    ip = BernsteinBasis{2,orders}()\n    qr_cell = QuadratureRule{2,RefCube}(4)\n    qr_face = QuadratureRule{1,RefCube}(3)\n\n    cv = BezierCellValues( CellVectorValues(qr_cell, ip) )\n    fv = BezierFaceValues( FaceVectorValues(qr_face, ip) )","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Distribute dofs as normal","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    dh = MixedDofHandler(grid)\n    push!(dh, :u, 2, ip)\n    close!(dh)","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Add two symmetry boundary condintions. Bottom face should only be able to move in x-direction, and the right boundary should only be able to move in y-direction","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    ch = ConstraintHandler(dh)\n    dbc1 = Dirichlet(:u, getfaceset(grid, \"bot\"), (x, t) -> 0.0, 2)\n    dbc2 = Dirichlet(:u, getfaceset(grid, \"right\"), (x, t) -> 0.0, 1)\n    add!(ch, dbc1)\n    add!(ch, dbc2)\n    close!(ch)\n    update!(ch, 0.0)","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Define stiffness matrix and traction force","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    stiffmat = get_material(E = 100, ν = 0.3)\n    traction = Vec((-10.0, 0.0))\n    K,f = assemble_problem(dh, grid, cv, fv, stiffmat, traction)","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Solve","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    apply!(K, f, ch)\n    u = K\\f","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Now we want to export the results to VTK. So we calculate the stresses in each gauss-point, and project them to the nodes using the L2Projector from JuAFEM. Node that we need to create new CellValues of type CellScalarValues, since the L2Projector only works with scalar fields.","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    cellstresses = calculate_stress(dh, cv, stiffmat, u)\n\n    csv = BezierCellValues( CellScalarValues(qr_cell, ip) )\n    projector = L2Projector(csv, ip, grid)\n    σ_nodes = project(cellstresses, projector)","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Output results to VTK","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"    vtkgrid = vtk_grid(\"plate_with_hole.vtu\", grid)\n    vtk_point_data(vtkgrid, dh, u, :u)\n    vtk_point_data(vtkgrid, σ_nodes, \"sigma\", grid)\n    vtk_save(vtkgrid)\n\nend;\nnothing #hide","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"Call the function","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"solve()","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"","category":"page"},{"location":"examples/example1/","page":"Infinite plate with hole","title":"Infinite plate with hole","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#IGA.jl","page":"Home","title":"IGA.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From wikipedia: * Isogeometric analysis is a computational approach that offers the possibility of integrating finite element analysis (FEA) into conventional NURBS-based CAD design tools. Currently, it is necessary to convert data between CAD and FEA packages to analyse new designs during development, a difficult task since the two computational geometric approaches are different. Isogeometric analysis employs complex NURBS geometry (the basis of most CAD packages) in the FEA application directly. This allows models to be designed, tested and adjusted in one go, using a common data set. *","category":"page"},{"location":"","page":"Home","title":"Home","text":"In IGA, one uses spline functions (B-splines, NURBS, T-slines etc) as base/shape functions for the FE-solutions. This comes with some advantages and disadvantages over traditional finite elements, where Lagrange functions are used as the basis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"IGA.jl can be seen as a module/add-on the the finite element package JuAFEM.jl. It uses many of the already existing data types like DofHandler, CellValues, L2Projector and more. ","category":"page"}]
}
